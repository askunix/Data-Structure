       
操作系统报告：多进程(线程)实现快速排序

目录
操作系统报告	1
1	设计思路及主要代码分析	3
1.1	实验目的	3
1.2	实验要求	3
1.3	设计思路	3
1.3.1	程序流程图	3
1.3.2	设计说明	5
1.3.3	程序结构设计	6
1.4	程序代码	7
1.4.1	多线程排序	7
1.4.2	多进程排序	18
2	实验结果及问题分析	29
2.1	多线程排序	29
2.1.1	运行结果	29
2.1.2	结果分析	29
2.2	多进程排序	30
2.2.1	运行结果	30
2.2.2	结果分析	31
3	实验小结	31
4	问题回答	32
5	附录	38
5.1	机器环境及配置	38
5.2	编译环境	38
5.3	程序及源码	38

1	设计思路及主要代码分析
1.1	实验目的
使用多进程(线程)方式，实现快速排序，体会多进程(线程)的实际应用中的优势。
1.2	实验要求
在Windows 环境下，编写一个多进程（线程）进行快速排序的程序，使用的是产生1，000，000个随机数的文件。
要求说明你的程序运行的系统资源配置，给出测试结果并对测试程序和结果做出说明。
1.3	设计思路
1.3.1	程序流程图
1)	多线程排序流程图
 
2)	多进程排序流程图
 
1.3.2	设计说明
1)	每次数据分割后产生两个新的进程（线程）处理分割后的数据，线程直接共享内存数据，进程间的数据交换采用内存映射文件。
2)	每个进程（线程）处理的数据小于1000以后不再分割（控制产生的进程在20个左右）。
3)	利用一些技巧使分割尽可能均匀：比较第一个、最后一个、中间一个，三者中中间值作为分割值。

1.3.3	程序结构设计
1）	可运行程序文件
程序主要为2个主运行程序和1个子进程排序程序。
2个主运行程序分别为：线程排序程序FileMapSort_Thread.exe和进程排序程序FileMapSort_Proc.exe。
1个子进程排序程序为：qsort_proc.exe。
2）	测试数据
程序中使用随机函数初始化1,000,000个测试使用的数据，写到二进制文件Unsorted.dat中，然后读取到内存或内存映射文件，以便多线程（进程）排序，排序后将结果写到二进制文件Sorted.dat中。
出于IO的性能考虑使用了二进制文件读写，另外，为了便于查看，排序前的数据和排序后的数据分别保存在了对应的Unsorted.txt和Sorted.txt中。
3）	时间计算
由于数据量较大，时间较长，使用GetTickCount（）即可。
1.4	程序代码
1.4.1	多线程排序
 
1）	主程序代码：FileMapSort_Thread.cpp
#include <stdio.h>
#include <windows.h>
#include "functions.h"

// 数据缓冲区指针
extern int* g_pData;	
// 数据量大小		
extern int g_nDataCount;		

// 信号量，用于控制排序线程的数目
HANDLE hSemaphoreThread = NULL;	
// 事件，用于通知控制台线程排序完成
HANDLE hEventSortOver = NULL;	


/**
 * 线程参数结构
 */
struct ThreadParam
{
	int* m_pData;	// 数据缓冲区指针
	int m_nLow;		// 数据开始下标
	int m_nHigh;	// 数据截止下标
};

/**
 * 线程函数
 */
DWORD WINAPI threadProc( LPVOID lpParam );

/**
 * 主函数
 */
void main( int argc, char** argv )
{

	//作业2：进程同步机制实验——生产者消费者问题
	//作者：夏磊 S1048035 
	//指导教师：陈向群、原仓周
	
	printf( "==================================================================\n" );
	printf( "           作业2-1：多线程实现快速排序\n" );
	printf( "==================================================================\n" );
	char szFileName[80];	// 文件名
	int nTimeGap = 0;		// 时间计数
	HANDLE hThread = NULL;  // 线程句柄

	// 初始化数据缓冲区，信号量和事件
	g_pData = new int[g_nCount];
	hSemaphoreThread = CreateSemaphore( NULL, g_nThreadBoundary, g_nThreadBoundary, NULL );
	hEventSortOver = CreateEvent( NULL, false, false, NULL );
	if( hSemaphoreThread==NULL || hEventSortOver==NULL )
	{
		printf( "信号量初始化失败！\n" );
		exit( GetLastError() );
	}

	strcpy( szFileName, "Unsorted.dat" );
	//随机初始化数据
	initDataFile(szFileName);
	// 读取数据	
	while( !readFile(szFileName) )
	{
		printf( "文件%s打开失败，请重新输入文件名：", szFileName );
		scanf( "%s", szFileName );
	}

	// 打印提示符
	printf( "……多线程排序开始……\n" );

	// 准备线程参数
	ThreadParam* param = new ThreadParam;
	param->m_pData = g_pData;
	param->m_nLow = 0;
	param->m_nHigh = g_nDataCount - 1;

	// 开始计时
	nTimeGap = GetTickCount();

	// 启动线程，开始排序
	WaitForSingleObject( hSemaphoreThread, INFINITE );
	if( (hThread=CreateThread(NULL, 0, threadProc, param, 0, NULL)) == NULL )
	{
		// 启动失败，中止程序
		delete param;
		printf( "线程产生失败！\n" );
		exit( GetLastError() );
	}
	WaitForSingleObject( hThread, INFINITE );       //判定hThread是否已经运行结束

	// 等待排序完成的消息
	WaitForSingleObject( hEventSortOver, INFINITE );//判定是否排序完成

	// 排序完成，停止计时
	nTimeGap = GetTickCount() - nTimeGap;

	// 打印控制台消息
	printf( "……多线程排序……\n------共耗时%d毫秒------\n", nTimeGap );

	// 写回数据
	strcpy( szFileName, "Sorted.dat" );
	while( !writeFile(szFileName) )
	{
		printf( "文件%s写入失败，请重新输入文件名：", szFileName );
		scanf( "%s", szFileName );
	}

	// 删除数据缓冲区
	delete[] g_pData;

	printf("------------------------------------------------------\n");  
	system("pause");
}

DWORD WINAPI threadProc( LPVOID lpParam )
{
	
	DWORD dwWaitResult;		// 等待结果
	HANDLE hThread;			// 线程句柄

	// 解析参数
	ThreadParam* param = (ThreadParam*)lpParam;
	int *pData = param->m_pData;
	int nLow = param->m_nLow;
	int nHigh = param->m_nHigh;

	// 若数据量已达限值以下，排序
	if( nHigh-nLow < g_nBoundary )
	{
		// 将数据排序
		quickSort( pData, nLow, nHigh );
		// 退出
		goto QUIT;
	}
	
	// 否则，将数据分块
	else
	{
		// 将数据分块
		//int nMid = partition( pData, nLow, nHigh );
		int nMid = randomizedPartition( pData, nLow, nHigh ) ;

		// 准备新线程的参数
		ThreadParam* param1 = new ThreadParam;
		ThreadParam* param2 = new ThreadParam;
		param1->m_pData = pData;
		param1->m_nLow = nLow;
		param1->m_nHigh = nMid;
		param2->m_pData = pData;
		param2->m_nLow = nMid + 1;
		param2->m_nHigh = nHigh;

		// 启动两个新线程
		dwWaitResult = WaitForSingleObject( hSemaphoreThread, 0L );
		if( dwWaitResult == WAIT_TIMEOUT )
		{
			threadProc( param1 );
			threadProc( param2 );
			goto QUIT;
		}
		else if( dwWaitResult == WAIT_OBJECT_0 )
		{
			if( (hThread=CreateThread(NULL, 0, threadProc, param1, 0, NULL)) == NULL )
			{
				// 启动失败，中止程序
				delete param;
				delete param1;
				delete param2;
				printf( "线程产生失败！\n" );
				exit( GetLastError() );
			}
			WaitForSingleObject( hThread, INFINITE );
		}
		dwWaitResult = WaitForSingleObject( hSemaphoreThread, 0L );
		if( dwWaitResult == WAIT_TIMEOUT )
		{
			threadProc( param2 );
			goto QUIT;
		}
		else if( dwWaitResult == WAIT_OBJECT_0 )
		{
			if( (hThread=CreateThread(NULL, 0, threadProc, param2, 0, NULL)) == NULL )
			{
				// 启动失败，中止程序
				delete param;
				delete param1;
				delete param2;
				printf( "线程产生失败！\n" );
				exit( GetLastError() );
			}
			WaitForSingleObject( hThread, INFINITE );
		}
	}

QUIT:
	// 删除当前线程的参数
	delete param;
	
	// 释放信号量
	long lPrevCount;
	if( !ReleaseSemaphore(hSemaphoreThread, 1, &lPrevCount) || lPrevCount==g_nThreadBoundary-1 )
	{
		SetEvent( hEventSortOver );
	}	

	// 退出
	return 0;
}



2）	排序及读写文件辅助程序头文件：functions.h
#pragma once

const int g_nCount = 1000000;		// 数据缓冲区大小
const int g_nThreadBoundary = 20;	// 线程数阖值
const int g_nBoundary = 1000;		// 排序阖值


/**
 * 初始化文件中数据
 */
bool initDataFile( char* szFileName );
/**
 * 从文件中读入数据
 */
bool readFile( char* szFileName );

/**
 * 将数据写入文件中
 */
bool writeFile( char* szFileName );
/**
 * 打印数据
 */
void printData(int* d);
/**
 * 写数据到文本文件
 */
void writeToCharFile(char* const szFileName,int* d);

/**
 * 数据分块算法
 */
int partition( int* pData, int nLow, int nHigh );
int randomizedPartition( int* pData, int nLow, int nHigh );

/**
 * 快速排序算法
 */
void quickSort( int* pData, int nLow, int nHigh );

/**
 * 选择排序算法
 */
void selectSort( int* pData, int nLow, int nHigh );
3）	排序及读写文件辅助程序实现：functions.cpp
#include <stdio.h>
#include <windows.h>
#include<time.h>
#include "functions.h"

int* g_pData = 0;		// 数据缓冲区指针
int g_nDataCount = 0;	// 数据量大小

bool initDataFile(char* szFileName)
{
	// 打开文件
	FILE* pFile = fopen( szFileName, "wb" );
	if( pFile == NULL )
	{
		return false;
	}
	int *A,i;
	A=new int[g_nCount];
	srand((unsigned int)time(0));//随机取种 以当前时间取种
	for(i=0;i<g_nCount;i++)
		A[i]=rand();//随机生成a数组

	// 写入数据
	g_nDataCount = fwrite( A, sizeof(int), g_nCount, pFile );
	//printf( "在二进制文件 %s 中初始化了%d个数据\n", szFileName,g_nDataCount );
	printf( "随机初始化了%d个数据\n",g_nDataCount );
	fclose( pFile );
	//printData(A);
	writeToCharFile(szFileName,A);
	return true;

}

bool readFile( char* szFileName )
{
	// 打开文件
	FILE* pFile = fopen( szFileName, "rb" );
	if( pFile == NULL )
	{
		return false;
	}

	// 读取数据
	g_nDataCount = fread( g_pData, sizeof(int), g_nCount, pFile );
	//printf( "从二进制文件 %s 中读取了%d个数据\n",szFileName, g_nDataCount );
	fclose( pFile );
	return true;
}

bool writeFile( char* szFileName )
{
	// 打开文件
	FILE* pFile = fopen( szFileName, "w" );
	if( pFile == NULL )
	{
		return false;
	}

	// 写入数据
	g_nDataCount = fwrite( g_pData, sizeof(int), g_nCount, pFile );
	//printf( "向二进制文件 %s 写入了%d个数据\n",szFileName, g_nDataCount );
	fclose( pFile );
	//printData(g_pData);
	writeToCharFile(szFileName,g_pData);
	return true;
}

void printData(int* d){
	printf("\n---------------------------------------------------------\n");
	for(int i=0;i<g_nCount;i++)
	{
		printf("%d",d[i]);
		if((i+1)%100!=0){
			printf(" ");
		}else{
			printf("\n");
		}
	}
	printf("\n---------------------------------------------------------\n");
	
}
void writeToCharFile(char* const szFileName,int* d)
{
	char fileName[80];
	strcpy(fileName,szFileName);
	strcpy(fileName+strlen(fileName)-3,"txt");

	FILE* pFile = fopen( fileName, "w" );
	if( pFile == NULL )
	{
		return ;
	}
	for(int i=0;i<g_nCount;i++)
	{
		char str[20];
		itoa(d[i],str,10);
		fwrite(str,1,strlen(str),pFile);
		if((i+1)%100!=0){
			fwrite(" ",1,strlen(" "),pFile);
		}else{
			fwrite("\n",1,strlen("\n"),pFile);
		}		

	}
	fclose( pFile );
	printf("可查看数据的文本文件%s \n",fileName);

}

int partition( int* pData, int nLow, int nHigh )
{
	// 算法结束
	if( nLow >= nHigh )
	{
		return nLow;
	}
	// 以第一个数为轴划分数组

	int pivot = pData[nLow];
	int i = nLow;
	int j = nHigh;
	while( i < j )
	{
		while( i<j && pData[j]>=pivot )
		{
			j--;
		}
		pData[i] = pData[j];
		while( i<j && pData[i]<=pivot )
		{
			i++;
		}
		pData[j] = pData[i];
	}
	pData[i] = pivot;

	// 返回轴位置
	return i;
}

int randomizedPartition( int* pData, int nLow, int nHigh )
{
	//int i = (int)(((rand()*(nHigh-nLow))%10000)/10000);
	int i=(int)((nLow+nHigh)/2);
	int temp;
	temp = pData[i];
	pData[i] = pData[nLow];
	pData[nLow] = temp;
	return partition(pData, nLow, nHigh );
	
}

int compare(const void*ele1 ,const void*ele2 )
{
	return *(int*)ele1 - *(int*)ele2 ;
}

void quickSort( int* pData, int nLow, int nHigh )
{
	// 算法结束
	if( nLow >= nHigh )
	{
		return;
	}
	//qsort( pData, nHigh-nLow, sizeof(pData[0]), compare );
	qsort( &(pData[nLow]), nHigh-nLow+1, sizeof(pData[0]), compare );

}

void selectSort( int* pData, int nLow, int nHigh )
{
	for( int i = nLow; i < nHigh; i++ )
	{
		// 获取数据pData[i...nHigh]中的最小数
		int nMin = pData[i];
		int index = i;
		for( int j = i; j < nHigh; j++ )
		{
			if( nMin > pData[j] )
			{
				nMin = pData[j];
				index = j;
			}
		}

		// 将最小数调入已排序区
		if( nMin < pData[i] )
		{
			pData[index] = pData[i];
			pData[i] = nMin;
		}
	}
}


1.4.2	多进程排序
 
1）	进程主程序：FileMapSort_Proc.cpp
#include <stdio.h>
#include <windows.h>
#include "fileOperation.h"
#define OUTFILE "C:\\Number.txt"     //创建一个文件内核对象

extern int* g_pData;  

char szEventName[80];		// 事件名
char szSemaphoreName[80];	// 信号量名
char szMapFileName[80];		// 内存映射文件名

HANDLE hEvent = NULL;		// 事件句柄，用于通知控制台进程排序完成
HANDLE hSemaphore = NULL;	// 信号量句柄，用于控制进程数

const int g_nProcessBoundary = 20;	// 进程数阖值

/**
 * 主函数
 */
int main( int argc, char** argv )
{

	//作业2-2：多进程实现快速排序
	//作者：夏磊 S1048035 
	//指导教师：陈向群、原仓周
	
	printf( "==================================================================\n" );
	printf( "           作业2-2：多进程实现快速排序\n" );
	printf( "           学生：夏磊 S1048035                        \n" );
	printf( "           指导教师：陈向群、原仓周                   \n" );
	printf( "==================================================================\n" );

	char szCommandLine[80];	// 命令行
	char szFileName[80];	// 文件名
	HANDLE hFile = NULL;	// 文件句柄
	HANDLE hMapFile = NULL;	// 内存映射文件句柄
	int nTimeGap = 0;		// 时间计数

	// 初始化事件和信号量
	strcpy( szEventName, "MyEvent" );
	strcpy( szSemaphoreName, "MySemaphore" );
	hEvent = CreateEvent( NULL, false, false, szEventName );
	hSemaphore = CreateSemaphore( NULL, g_nProcessBoundary, g_nProcessBoundary, szSemaphoreName );
	if( hEvent==NULL || hSemaphore==NULL )
	{
		exit( GetLastError() );
	}

	// 映射到共享内存区
	//hFile = (HANDLE)0xffffffff;
	//映射到文件内核对象OUTFILE
	hFile=CreateFile(OUTFILE,GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);

	// 创建内存映射文件
	strcpy( szMapFileName, "MyMapFile" );
	hMapFile = CreateFileMapping( hFile, NULL, PAGE_READWRITE, 0, 32*sizeof(int)*g_nCount, szMapFileName );
	if( hMapFile == NULL )
	{
		exit( GetLastError() );
	}

	// 映射内存
	g_pData = (int*)MapViewOfFile( hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, 0 );

	/**
	 * 开始进入多进程快速排序
	 */
	
	//生成的随机数存储于当前路径下的Unsorted.dat文件中
	strcpy( szFileName, "Unsorted.dat" );  

	//随机初始化数据
	initDataFile(szFileName);
	// 读取数据文件
	readFile( szFileName );
	//强制系统将修改过的数据部分或者全部重新写入磁盘映像，否则系统将其放入高速缓存
	FlushViewOfFile( g_pData, 0 );  

	// 建立命令行
	sprintf( szCommandLine, "qsort_proc.exe %s %s %s %d %d", szEventName, szSemaphoreName, szMapFileName, 0, g_nCount-1 );

	// 启动排序进程
	printf( "……多进程排序开始……\n" );
	//对控制进程数量的信号量进行P操作
	WaitForSingleObject( hSemaphore, INFINITE );    
	SECURITY_ATTRIBUTES sa;
	//进程启动信息
	STARTUPINFO si;      
    //进程信息
	PROCESS_INFORMATION pi;  
	sa.bInheritHandle = true;
	sa.lpSecurityDescriptor = NULL;
	sa.nLength = sizeof( sa );
	//fill a block of memory with zeros
	ZeroMemory( &si, sizeof(si) );  
	si.cb = sizeof( si );
	ZeroMemory( &pi, sizeof(pi) );
	printf("      ---------------------------\n"); 
	printf("      启动第一个子进程执行命令为： \n      %s \n",szCommandLine);
	printf("      其他子进程执行命令类似......\n"); 
	printf("      ---------------------------\n"); 
	//开始计时
	nTimeGap = GetTickCount();    
	if( !CreateProcess(NULL, szCommandLine, &sa, NULL, false, 0, NULL, NULL, &si, &pi) )
	{
		printf( "进程 %s 启动失败！\n", szCommandLine );
		exit( GetLastError() );
	}

	// 等待排序结束，打印结果
	WaitForSingleObject( hEvent, INFINITE );
	nTimeGap = GetTickCount() - nTimeGap;
	printf( "……多进程排序完成……\n------共耗时%d毫秒------\n", nTimeGap );

	// 将结果写入文件
	strcpy( szFileName, "Sorted.dat" );
	writeFile( szFileName );
	UnmapViewOfFile( g_pData );

	// 关闭文件
	CloseHandle( hMapFile );
	CloseHandle( hFile );
	printf("------------------------------------------------------\n"); 
	system("pause");    
	return 0;
}
2）	进程读写文件辅助程序：fileOperation.cpp
#include <stdio.h>
#include <windows.h>
#include<time.h>
#include "fileOperation.h"

int* g_pData = 0;		// 数据缓冲区指针
int g_nDataCount = 0;	// 数据量大小

bool initDataFile(char* szFileName)
{
	// 打开文件
	FILE* pFile = fopen( szFileName, "wb" );
	if( pFile == NULL )
	{
		return false;
	}
	int *A,i;
	A=new int[g_nCount];
	srand((unsigned int)time(0));//随机取种 以当前时间取种
	for(i=0;i<g_nCount;i++)
		A[i]=rand();//随机生成a数组
	
	// 写入数据
	g_nDataCount = fwrite( A, sizeof(int), g_nCount, pFile );
	//printf( "在二进制文件 %s 中初始化了%d个数据\n", szFileName,g_nDataCount );
	printf( "随机初始化了%d个数据\n",g_nDataCount );
	fclose( pFile );
	//printData(A);
	writeToCharFile(szFileName,A);
	return true;
	
}

bool readFile( char* inputFile )
{
	// 打开文件
	FILE* fileName = fopen( inputFile, "rb" );
	if( fileName == NULL )
	{
		printf("从文件%s中读入出错\n",fileName) ;
		return false;
	}

	g_nDataCount = fread( g_pData, sizeof(int), g_nCount, fileName );
	//printf( "成功读取了%d个数据\n", g_nDataCount );
	fclose( fileName );
	return true;
}

bool writeFile( char* szFileName )
{
	// 打开文件
	FILE* fileName = fopen( szFileName, "wb" );
	if( fileName == NULL )
	{
		return false;
	}

	// 写入数据
	g_nDataCount = fwrite( g_pData, sizeof(int), g_nCount, fileName );
	//printf( "成功写入了%d个数据\n", g_nDataCount );   //在这里应该检查写入和写出的数据是否一样多
	fclose( fileName );
	writeToCharFile(szFileName,g_pData);
	return true;
}

void writeToCharFile(char* const szFileName,int* d)
{
	char fileName[80];
	strcpy(fileName,szFileName);
	strcpy(fileName+strlen(fileName)-3,"txt");
	
	FILE* pFile = fopen( fileName, "w" );
	if( pFile == NULL )
	{
		return ;
	}
	for(int i=0;i<g_nCount;i++)
	{
		char str[20];
		itoa(d[i],str,10);
		fwrite(str,1,strlen(str),pFile);
		if((i+1)%100!=0){
			fwrite(" ",1,strlen(" "),pFile);
		}else{
			fwrite("\n",1,strlen("\n"),pFile);
		}		
		
	}
	fclose( pFile );
	printf("可查看数据的文本文件%s \n",fileName);
	
}
3）	子进程排序程序：qsort_proc.cpp
#include <stdio.h>
#include <windows.h>
#include "sort.h"

extern int* g_pData;		// 数据缓冲区指针,即指向未排序数组
const int g_nProcessBoundary = 20; // 最大进程数

char szEventName[80];		// 事件名
char szSemaphoreName[80];	// 信号量名
char szFileName[80];		// 内存映射文件名

HANDLE hEvent = NULL;		// 事件，用于通知控制台线程排序完成
HANDLE hSemaphore = NULL;	// 信号量，用于控制进程数
HANDLE hFile;				// 内存映射文件句柄

/**
 * 进程的执行函数
 */
void processProc( int* pData, int nLow, int nHigh );

/**
 * 主函数
 */
int main( int argc, char** argv )
{
	int nLow;					// 数据起始下标
	int nHigh;					// 数据截止下标

	// 检测参数数目
	if( argc != 6 )
	{
		printf("qsort_proc.exe 的执行的参数需要6个！\n");
		exit( -1 );
	}

	// 输出提示信息
	//printf("子进程创建成功\n") ;

	// 解析参数，获取事件名
	strcpy( szEventName, argv[1] );

	// 解析参数，获取信号量名
	strcpy( szSemaphoreName, argv[2] );

	// 解析参数，获取内存映射文件名
	strcpy( szFileName, argv[3] );

	// 解析参数，获取数据起始下标
	nLow = atoi( argv[4] );

	// 解析参数，获取数据截止下标
	nHigh = atoi( argv[5] );

	// 打开事件
	hEvent = OpenEvent( EVENT_ALL_ACCESS, true, szEventName );
	if( hEvent == NULL )
	{
		printf( "事件%s打开失败！\n", szEventName );
		exit( GetLastError() );
	}

	// 打开信号量
	hSemaphore = OpenSemaphore( SEMAPHORE_ALL_ACCESS, true, szSemaphoreName );
	if( hSemaphore == NULL )
	{
		printf( "信号量%s打开失败！\n", szSemaphoreName );
		exit( GetLastError() );
	}

	// 打开内存映射文件
	hFile = OpenFileMapping( FILE_MAP_ALL_ACCESS, false, szFileName );
	if( hFile == NULL )
	{
		printf( "内存映射文件%s打开失败！\n", szFileName );
		exit( GetLastError() );
	}

	// 建立文件映射视图
	g_pData = (int*)MapViewOfFile( hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
	if( g_pData == NULL )
	{
		printf( "内存映射失败！\n" );
		exit( GetLastError() );
	}

	// 执行排序函数
	processProc( g_pData, nLow, nHigh );
	
	// 删除参数，准备退出
	UnmapViewOfFile( g_pData );

	// 察看进程数，若排序完成，发信号给控制台进程
	long lPrevCount;
	if( !ReleaseSemaphore(hSemaphore, 1, &lPrevCount) || lPrevCount==g_nProcessBoundary-1 )
	{
		SetEvent( hEvent );
	}
	CloseHandle( hSemaphore );
	CloseHandle( hEvent );
	CloseHandle( hFile );
	return 0;
}

void processProc( int* pData, int nLow, int nHigh )
{
	// 若数据量已达限值以下，内排序
	if( nHigh-nLow < g_nBoundary )
	{
		// 将数据内排序，这里使用快速排序和选择排序比较。结果证明快速排序快将近一倍
		quickSort( g_pData, nLow, nHigh ) ;
		//selectSort( g_pData, nLow, nHigh );

		// 退出
		return;
	}
	
	// 否则，将数据分块
	else
	{
		char szCommandLine[80];	// 新进程的命令行
		DWORD dwWaitResult;		// 等待信号结果
		STARTUPINFO si;			// 进程启动信息
		PROCESS_INFORMATION pi;	// 进程信息

		// 将数据分块
		int nMid = partition( pData, nLow, nHigh );
		//int nMid = randomizedPartition( pData, nLow, nHigh );

		if( nMid-nLow < g_nBoundary ){ //如果数据量小于阈值则无需创建进程
				quickSort(pData, nLow, nMid ) ;
				//selectSort( g_pData, nLow, nHigh );		
		}
		else
		{ 
			// 测试进程数
			dwWaitResult = WaitForSingleObject( hSemaphore, 0L );  //对进程数量的信号量进行P操作
			if( dwWaitResult == WAIT_TIMEOUT )    //不能创建新的进程     
			{
				processProc( pData, nLow, nMid );
				processProc( pData, nMid+1, nHigh );
				return;
			}
			else   //可以创建子进程
			{
				// 准备新进程的命令行，将nMid到nLow部分交给子进程部分来完成
				sprintf( szCommandLine, "qsort_proc.exe %s %s %s %d %d", szEventName, szSemaphoreName, szFileName, nLow, nMid );

				// 启动新进程
				ZeroMemory( &si, sizeof(si) );
				si.cb = sizeof(si);
				ZeroMemory( &pi, sizeof(pi) );
				if( !CreateProcess(NULL, szCommandLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi) )
				{
					// 启动失败，中止程序
					UnmapViewOfFile( g_pData );
					printf( "子进程产生失败！\n" );
					exit( -1 );
				}
			}
		}

		if( nHigh-nMid-1 < g_nBoundary ){  //要处理的数据如果小于阈值则无需创建子进程
				quickSort(g_pData, nMid+1, nHigh ) ;
				//selectSort( g_pData, nLow, nHigh );
		}
		
		else
		{ 
			dwWaitResult = WaitForSingleObject( hSemaphore, 0L ); //对进程数量的信号量进行P操作
			if( dwWaitResult == WAIT_TIMEOUT ) //进程数已经达到20个
			{
				processProc( pData, nMid+1, nHigh );
				return;
			}
			else   //可以创建子进程
			{			
				// 准备新进程的命令行，将nMid+1到nHigh部分交给子进程来完成
				sprintf( szCommandLine, "qsort_proc.exe %s %s %s %d %d", szEventName, szSemaphoreName, szFileName, nMid+1, nHigh );

				// 启动新进程
				ZeroMemory( &si, sizeof(si) );
				si.cb = sizeof(si);
				ZeroMemory( &pi, sizeof(pi) );
				if( !CreateProcess(NULL, szCommandLine, NULL, NULL, false, 0, NULL, NULL, &si, &pi) )
				{
					// 启动失败，中止程序
					UnmapViewOfFile( g_pData );
					printf( "子进程产生失败！\n" );
					exit( -1 );
				}
			}
		}
	}
}
2	实验结果及问题分析
2.1	多线程排序
2.1.1	运行结果
 
 
2.1.2	结果分析
多线程排序运行后，产生随机数初始化数据，并写入测试文件中，然后主程序将测试文件中的数据读入内存，设置信号量、事件等，开启线程进行排序，线程通过快速排序的分区方式再开启新的线程进行递归排序，直到数据量小于1000时，不再开启线程，直接进行排序，排序结束后发送消息给主程序，最后将排序数据写入文件，并清理内存。
2.2	多进程排序
2.2.1	运行结果
 

 

2.2.2	结果分析
多进程程排序运行后，产生随机数初始化数据，并写入测试文件中，然后主程序将测试文件做了内存文件映射，设置信号量、事件等，之后开启子进程进行排序，子进程打开内存映射文件将数据读入内存，进行快速排序递归处理，如果要排序的数据量大于1000，则按照快速排序方式进行分区，并开启新的子进程递归处理，直到小于1000时，直接进行排序，字进行排序结束后，发送事件消息通知主程序，最后将排序数据写入文件，并清理内存。

3	实验小结
本次的实验，使我对多进程（线程）的实际应用有了更加深刻的了解。
从线程和进程的结果比较上看，多进程排序比多线程排序速度更快，进程可以真正利用实际四核CPU并发执行；而线程只用启动进程的CPU模拟并发执行。
通过实验，更加理解了线程和进程对在内存共享和通信方面的区别。
4	问题回答
4.1	对数据分割的均匀程度对排序的时间有何影响，为什么会有这种影响？ 
答：
1）	数据分割均匀时，排序效率较高，历时较短；
2）	数据分割不均匀时，排序效率不高，历时较长；
原因：分割不均匀时，文件间的交换频繁，换进换出内存频繁，从而严重影响系统效率。
4.2	分解到每个线程的排序算法应不应采用快速排序算法，为什么？ 
答：
快速排序算法对数据量很大的时候才有效，而在线程处理的数据量相对来说比较小，从而效率不明显。
4.3	如何通过数据量和边界条件来控制参与排序的线程数？ 
答：
每个进程（线程）处理的数据小于1000以后不再分割（控制产生的进程在20个左右）
4.4	在多线程协同工作的过程中，进程之间有几种办法实现通信？各有什么特点？
答：
	同步互斥问题
	信号量及P、V操作
	进程间高级通信
1）	进程的同步：synchronism
指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成一项任务。具体说，一个进程运行到某一点时要求另一伙伴进程为它提供消息，在未获得消息之前，该进程处于等待状态，获得消息后被唤醒进入就绪态，由于各进程要求共享资源，而有些资源需要互斥使用，因此各进程间竞争使用这些资源，进程的这种关系为进程的互斥。
2）	信号量
以上介绍的各种算法都存在问题，它们是平等进程间的一种协商机制，需要一个地位高于进程的管理者来解决公有资源的使用问题。
操作系统可从进程管理者的角度来处理互斥的问题，信号量就是操作系统提供的管理公有资源的有效手段。
3）	共享内存
相互通信的进程间设有公共内存，一组进程向该公共内存中写，另一组进程从公共内存中读，通过这种方式实现两组进程间的信息交换。
4）	消息传递
系统为进程提供了两个高级通讯原语send和receive
5）	消息传递模式
消息缓冲
在内存中开设缓冲区，发送进程将消息送入缓冲区，接收进程接收传递来的缓冲区。
信箱通信
6）	共享文件模式
管道通信。
7）	内存映射机制
共享存储区(shared memory)可用于进程间的大数据量通信。
进行通信的各进程可以任意读写共享存储区，也可在共享存储区上     使用任意数据结构。
在使用共享存储区时，需要进程互斥和同步机制的辅助来确保数据 一致性。
Windows 2000/XP采用文件映射(file mapping)机制来实现共享存储区，用户进程可以将整个文件映射为进程虚拟地址空间的一部分来加以访问。
4.5	在Windows中，内存映射文件是如何使用的（步骤）。
答：
1)	CreateFileMapping为指定文件创建一个文件映射对象，返回对象指针。
2)	OpenFileMapping打开一个命名的文件映射对象，返回对象指针。
3)	MapViewOfFile把文件映射到本进程的地址空间，返回映射地址空间的首地址。
4)	FlushViewOfFile可把映射地址空间的内容写到物理文件中。
5)	UnmapViewOfFile拆除文件映射与本进程地址空间间映射关系。
6)	CloseHandle可关闭文件映射对象。当完成文件到进程地址空间的映射后，就可利用首地址进行读写。
4.6	建立内存映射文件的过程中使用的命令OpenFileMapping需要哪些参数，表达什么含义？ 
答：
HANDLE OpenFileMapping(
DWORD,
BOOL,
LPCTSTR 
);

•说明：打开一个现成的文件映射对象 
•返回值：指定文件映射对象的句柄，零表示出错 
•参数 
dwDesiredAccess ：参考MapViewOfFile函数的dwDesiredAccess参数的说明 
bInheritHandle ：如这个函数返回的句柄能由当前进程启动的新进程继承，则这个参数为TRUE 
lpName ：指定要打开的文件映射对象名称
4.7	进程和线程在处理数据通信上有何差别，为什么会有这种差别？
答：
线程可以共享进程中的资源。
而进程之间各自拥有各自资源，不可以共享。
线程效率较高
4.8	用多进程实现和用多线程实现有哪些不同，产生这些不同的原因是什么？
答：
每一次运行结果都有很大的不确定性,虽然原则上线程因为各个之间共享系统的资源,他们只是cpu的调度单位,而进程不但是cpu的调度单位还是各种资源的分配单位.好像线程应该大大快于进程的排序速度,可从结果可以看出就本题来说四核CPU时，进程反而要比线程要快。
线程所用时间1312ms，进程所用时间547ms。如果都是单核来看，线程的速度还是比进程要快些。
4.9	本实验用到的重要函数及其参数，名称及含义。 
答：
CreateFile 
•说明：全功能的例程，可打开和创建文件、管道、邮槽、通信服务、设备以及控制台 
•返回值：Long，如执行成功，则返回文件句柄。INVALID_HANDLE_VALUE表示出错，会设置GetLastError 
•参数 
dwDesiredAccess：若为 GENERIC_READ 表示允许对设备进行读访问；若为 GENERIC_WRITE 表示允许对设备进行写访问（可组合使用）；若为零，表示只允许获取与一个设备有关的信息 
dwShareMode ：零表示不共享； FILE_SHARE_READ 和/或 FILE_SHARE_WRITE 表示允许对文件进行共享访问 
dwFlagsAndAttributes ：指定文件属性和标志，可取多种组合 
dwCreationDisposition ：对文件采取的措施
CreateFileMapping 
•说明：创建一个新的文件映射对象 
•返回值：新建文件映射对象的句柄；零表示出错 
•参数 
hFile :指定欲在其中创建映射的一个文件句柄 
lpFileMappigAttributes:指定一个安全对象，在创建文件映射时使用 
flProtect :PAGE_READWRITE 表示以可读可写方式打开映射 
dwMaximumSizeHigh 和dwMaximumSizeLow ：设为0表示使用磁盘文件的实际长度
MapViewOfFile 
•说明：将一个文件映射对象映射到当前应用程序的地址空间 
•返回值：文件映射在内存中的起始地址，零表示出错 
•参数 
hFileMappingObject ：文件映射对象的句柄 
dwDesiredAccess ：多种方式，其中FILE_MAP_ALL_ACCESS 表示映射可读可写
OpenFileMapping 
•说明：打开一个现成的文件映射对象 
•返回值：指定文件映射对象的句柄，零表示出错 
•参数 
dwDesiredAccess ：参考MapViewOfFile函数的dwDesiredAccess参数的说明 
bInheritHandle ：如这个函数返回的句柄能由当前进程启动的新进程继承，则这个参数为TRUE 
lpName ：指定要打开的文件映射对象名称
5	附录
5.1	机器环境及配置
CPU	内存	操作系统	类型
i5,M460,四核2.53Hz	4G	XP	Lenovo笔记本
5.2	编译环境
MicroSoft Visual C ++ 6.0
5.3	程序及源码
请参看同级目录的“程序源码目录”和“运行程序目录”。
